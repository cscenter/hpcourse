# Использование pthread API

Ваша задача - реализовать классический паттерн producer-consumer с небольшими дополнительными условиями. Программа должна состоять из 3+N потоков:

1. главный
2. producer
3. interruptor
4. N потоков consumer

В программе должена быть предусмотрена обработка ошибок через механизм статус-кодов, устанавливаемых для каждого потока индивидуально при помощи функций `set_last_error(int)` и `get_last_error()`. Хранение текущего значения ошибки должно осуществляться в TLS-переменной. Значение `NOERROR(0)` означает отсутствие ошибки.

На стандартный ввод программе подается строка - список чисел, разделённых пробелом. Длина списка чисел не задаётся - считывание происходит до перевода каретки.

* Задача producer-потока - получить на вход список чисел, и по очереди использовать каждое значение из этого списка для обновления переменной разделяемой между потоками
* Задача consumer-потоков отреагировать на уведомление от producer и набирать сумму полученных значений. Также этот поток должен защититься от попыток потока-interruptor его остановить. Дополнительные условия:

  1. Функция, исполняющая код этого потока consumer_routine, должна принимать указатель на объект/переменную, из которого будет читать обновления
  2. После суммирования переменной поток должен заснуть на случайное количество миллисекунд, верхний предел будет передан на вход приложения (0 миллисекунд также должно корректно обрабатываться). Вовремя сна поток не должен мешать другим потокам consumer выполнять свои задачи, если они есть
  3. Потоки consumer не должны дублировать вычисления друг с другом одних и тех же значений
  4. Поток должен отслеживать арифметическое переполнение, если очередная операция сложения приведет к переполнению, поток должен выставить код ошибки OVERFLOW(1) и завершиться
  5. В качестве возвращаемого значения поток должен вернуть свою частичную посчитанную сумму и код ошибки

* Задача потока-interruptor проста: пока происходит процесс обновления значений, он должен постоянно пытаться остановить случайный поток consumer (вычисление случайного потока происходит перед каждой попыткой остановки). Как только поток producer произвел последнее обновление, этот поток завершается.

Функция `run_threads()` должна запускать все потоки, дожидаться их выполнения, и возвращать результат общего суммирования. Если возникло арифметическое переполнение, необходимо вывести `overflow` (в нижнем регистре) и вернуть код возврата `1` из `main()`.

Для обеспечения межпоточного взаимодействия допускается использование только *pthread API*. На вход приложения передаётся 2 аргумента при старте именно в такой последовательности:

1. Число потоков consumer
2. Верхний предел сна consumer в миллисекундах
В поток вывода должно попадать только результирующее значение, по умолчанию никакой отладочной или запросной информации выводиться не должно.

```
#include <pthread.h>


#define NOERROR 0 
#define OVERFLOW 1


int get_last_error() {
  // return per-thread error code
}


void set_last_error(int code) {
  // set per-thread error code
}


void* producer_routine(void* arg) {
  // wait for consumer to start
  // read data, loop through each value and update the value, notify consumer, wait for consumer to process 
}


void* consumer_routine(void* arg) {
  // notify about start
  // for every update issued by producer, read the value and add to sum 
  // return pointer to result (for particular consumer)
}


void* consumer_interruptor_routine(void* arg) { 
  // wait for consumers to start
  // interrupt random consumer while producer is running 
}


int run_threads() { 
  int sum = 0;


  // start N threads and wait until they're done
  // return aggregated sum of values


  std::cout << sum << std::endl;
  return 0;
}


int main() { 
  return run_threads();
}
```
Решение должно содержать один cpp файл, который должен компилироваться командой:
```
g++ -std=c++11 -pthread *.cpp -o lab
```
Также приветствуется наличие Make или CMake файлов для сборки. Порядок сдачи работ:

1. Вы делаете форк репозитория https://github.com/cscenter/hpcourse/tree/master/csc/2019
2. Создаете директорию названную своей фамилией и инициалами в формате IvanovIS и решаете задачу
3. Делаете pull request в наш репозиторий
При возникновении любых вопросов не стесняйтесь нам писать в Slack либо на почту.
